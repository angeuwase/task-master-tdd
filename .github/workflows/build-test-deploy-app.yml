












# This workflow will:
# 1. Run unit and functional tests on the code
# 2. Build the docker image 
# 3. Test the docker image 
# 4. Deploy to AWS using Elastic Beanstalk.

name: Build-Test-Deploy

on:
  push:
    branches: [ main ]
jobs:

  # First Job: Build the project and run the tests
  build-test:

    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python 3.8
      uses: actions/setup-python@v2
      with:
        python-version: 3.8
        
    - name: Install dependencies
      run: |
        # create instance folder where log file and db file are saved. Its gitignored when code is pushed to master
        mkdir instance
        python -m pip install --upgrade pip
        pip install flake8 pytest
        pip install -r requirements.txt
        
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
    - name: Test with pytest
      run: |
        python -m pytest
        
    - name: Print job completion message
      run: echo "Code built and tested successfully" 
   
  # Second job: build and test docker image
  docker-image:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Set up Python 3.8
        uses: actions/setup-python@v2
        with:
          python-version: 3.8
      - name: Build docker image
        run: docker build --file Dockerfile --tag taskmaster .
      - name: Test docker image
        run: |
          import time
          from subprocess import check_call
          from urllib.request import urlopen
          check_call(
              "docker run --rm --name=taskmaster_container -p 5000:5000 -d taskmaster".split()
          )
          # Wait for the server to start. A better implementation
          # would poll in a loop:
          time.sleep(5)
          # Check if the server started (it'll throw an exception
          # if not):
          try:
              urlopen("http://localhost:5000").read()
          finally:
              check_call("docker kill smk".split())
          

  

   
   
   

